package at.erp.light.view.mapper;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashSet;
import java.util.Set;
import java.util.logging.Logger;

import at.erp.light.view.dto.OutgoingArticleDTO;
import at.erp.light.view.dto.OutgoingDeliveryDTO;
import at.erp.light.view.model.OutgoingArticle;
import at.erp.light.view.model.OutgoingDelivery;
import at.erp.light.view.services.IDataBase;

/**
 * This class acts as mapper class between entity OutgoingDelivery and DTO OutgoingDeliveryDTO.
 * @author Matthias Schnöll
 *
 */
public class OutgoingDeliveryMapper {
	private static DateFormat df = new SimpleDateFormat("dd.MM.yyyy");
	private static final Logger log = Logger
			.getLogger(OutgoingDeliveryMapper.class.getName());

	/**
	 * Maps the given entity to a DTO.
	 * @param entity Entity from the DB
	 * @return DTO object
	 */
	public static OutgoingDeliveryDTO mapToDTO(OutgoingDelivery entity) {
		if (entity == null) {
			return null;
		}

		OutgoingDeliveryDTO dto = new OutgoingDeliveryDTO();

		dto.setOutgoingDeliveryId(entity.getOutgoingDeliveryId());
		dto.setDeliveryNr(entity.getDeliveryNr());
		dto.setOrganisationId(entity.getOrganisation().getOrganisationId());
		dto.setLastEditorId(entity.getLastEditor().getPersonId());
		dto.setDeliveryNr(entity.getDeliveryNr());
		dto.setDate(df.format(entity.getDate()));
		dto.setComment(entity.getComment());
		dto.setBooked(entity.getBooked());
		dto.setArchived(entity.getArchived());
		dto.setUpdateTimestamp(df.format(entity.getUpdateTimestamp()));

		Set<OutgoingArticleDTO> outgoingArticleDTOs = new HashSet<OutgoingArticleDTO>();
		for (OutgoingArticle outgoingArticle : entity.getOutgoingArticles()) {
			outgoingArticleDTOs.add(OutgoingArticleMapper
					.mapToDTO(outgoingArticle));
		}

		dto.setOutgoingArticleDTOs(outgoingArticleDTOs);

		return dto;
	}

	/**
	 * Maps the given DTO to an entity.
	 * @param dto DTO object from the frontend
	 * @param dataBaseService DataBaseService class for getting data, needed for the mapping
	 * @return entity
	 */
	public static OutgoingDelivery mapToEntity(OutgoingDeliveryDTO dto,
			IDataBase dataBaseService) {

		if (dto == null) {
			return null;
		}
		OutgoingDelivery entity = new OutgoingDelivery();

		entity.setOutgoingDeliveryId(dto.getOutgoingDeliveryId());
		entity.setDeliveryNr(dto.getDeliveryNr());

		try {
			entity.setOrganisation(dataBaseService.getOrganisationById(dto
					.getOrganisationId()));
			entity.setLastEditor(dataBaseService.getPersonById(dto
					.getLastEditorId()));
		} catch (Exception e) {
			log.severe(e.getMessage());
			e.printStackTrace();
		}

		entity.setDeliveryNr(dto.getDeliveryNr());
		
		try {
			entity.setDate(df.parse(dto.getDate()));
		} catch (ParseException e) {
			e.printStackTrace();
		}
		
		// updateTimestamp does not have to be delivered by the frontend
		if (dto.getUpdateTimestamp() != null)
		{
			try {
				entity.setUpdateTimestamp(df.parse(dto.getUpdateTimestamp()));
			} catch (ParseException e) {
				// set current Date if parsing fails
				entity.setUpdateTimestamp(new Date(System.currentTimeMillis()));
				e.printStackTrace();
			}
		}
		
		entity.setComment(dto.getComment());
		// set archived status only by function, not by object
		// entity.setArchived(dto.getArchived());
		// booked status does not have to be set, because it is generated by Hibernate when getting the entity

		Set<OutgoingArticle> outgoingArticles = new HashSet<OutgoingArticle>();
		for (OutgoingArticleDTO outgoingArticleDTO : dto
				.getOutgoingArticleDTOs()) {
			outgoingArticles.add(OutgoingArticleMapper
					.mapToEntity(outgoingArticleDTO));
		}

		entity.setOutgoingArticles(outgoingArticles);

		return entity;

	}
}
